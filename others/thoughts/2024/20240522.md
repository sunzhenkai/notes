---
title: 你行走的时候会一直看路上有钉子吗？
categories: 
  - [碎碎念]
tags:
  - 碎碎念
date: 2024/05/22 00:00:00
---

先从线上发现的一个小问题说起。

先说下背景，我们有个仓库维护公共的 proto 文件，且配置了 CI/CD，合并时触发编译，并打新的 tag。我们有个服务 A，依赖这个库。

小问题发生的过程如下。

-  proto 仓库增加了一个文件，该文件没有指定 `go_package` ，CI/CD 触发编译，生成 go 代码时报错（proto 未指定 go_package），tag 未更新
- 服务 A 需求，需要向 proto 文件新增字段，合并后等待 CI/CD 触发编译
- 等一段时间后，拷贝最新 tag（路径依赖，感觉留了足够时间跑编译流程，实际编译失败，最新的 tag 未包含改动）
- 服务 A 上线
- 上线后发现不符合预期
- 修复 proto 编译问题后，发布 hotfix 版本

上面是小问题短周期的描述，如果把时间线拉长。

- A 服务创建了一个 DEPENDS 文件，记录依赖的库及其版本，编译时通过脚本读取
- 对 A 服务进行重构，重构服务就记为 B
- 从 proto 库中拷贝需要的文件到服务 B 的代码库
- 对 B 代码库的 proto 进行新增、修改
- 觉得这种方式很容易出问题
  - 把服务 B 内 proto 的改动迁移到 proto 仓库
  - 通过 git submodule 的方式，在服务 B 内引入 proto 文件
- 服务 B 是 C++ 服务，无需生成 go 代码，估新加的 proto 文件无 go_package
- **此处接小问题发生过程**

至此，这个事情陈述完毕。

我想再讲一个 case。我们在做用户数据迭代时，需要离线写入一份事件列表数据，我期望的是存储团队交付一个按时间戳由大及小排序好的时间序列，这样线上读取时无需再做一次排序。最后评审时，交付的是一个 map 结构，提出异议时，存储团队坚持认为 cassandra 集群的 map 是有序的，故符合需求，最终以 map 结构交付。由于原有封装好的读取接口，对 cassandra map 结构使用 unordered_map 保存。迫于排期，只能先读为 unordered_map，再转换为 vector，最后按时间戳排序。然而事情并没有结束，在后续做特征一致性校验时，出现不一致，原因是在以 map 存储时，key 是以秒为单位的时间戳，故如果多个事件具有相同的时间戳，只能保留一个。

想讲这些问题，是因为这样的事情，在过去的日子里，一次又一次的发生。更痛苦的是，在将来的日子里，也会一次又一次的发生。

更恐怖的是，当出现问题，我们往往舍本逐末、不追究 root cause，却做了很多其他的事情。就像，我们走路的时候，脚被钉子扎了，于是穿上了铁板鞋、两手提着两个大磁铁、身上背着医药箱、头低到膝盖走路，然而一切的原因，只是为了抄一点近路而选择了满是建筑废料的小路。

如果说两点之间直线最短，那么以正确的方式做正确的事情就是那条直线。

正确的方式，一定是简单且优雅的。

最后，因为偷懒或者其他原因**留的每个坑，只要时间足够长，都会被踩到**，而且可能**不止一个地方，不止一次**。**不挖坑，就不会踩坑。**
